// START: From previous lecture
const then = <a,b,c>(f: Fun<a,b>, g: Fun<b,c>): Fun<a,c> => Fun<a,c>(a => g.f(f.f(a)))
type Fun<a,b> = { f: (i: a) => b, then: <c>(g: Fun<b,c>) => Fun<a,c> }
let Fun = <a,b>(f: (_: a) => b): Fun<a,b> => {
    return {
        f: f,
        then: function<c>(this: Fun<a,b>, g: Fun<b,c>): Fun<a,c> {
            return then(this, g)
        }
    }
}

// Identity function (does nothing to the value)
const id = <a>(): Fun<a,a> => Fun<a,a>(x => x)

// Simple applications
const incr = Fun<number, number>(x => x + 1)
const double = Fun<number, number>(x => x * 2)
const decr = Fun<number, number>(x => x - 1)
const negate = Fun<boolean, boolean>(x => !x)
const is_even = Fun<number, boolean>(x => x % 2 == 0)
const is_odd = Fun<number, boolean>(x => x % 2 !== 0)
const convert = Fun<number, string>(x => String(x))
const square = Fun<number, number>(x => x * x)
const is_positive = Fun<number, boolean>((x: number) => x > 0)
const square_root = Fun<number, number>((x: number) => Math.sqrt(x))
const invert = Fun<number, number>((x: number) => -x)
const is_true = Fun<boolean, boolean>(x => x === true)
const is_false = Fun<boolean, boolean>(x => x === false)
const is_greater_than_zero = Fun<number, boolean>(x => x > 0)
const array_length = Fun<Array<{}>, number>(x => x.length)

const incr_twice = incr.then(incr)
const double_twice = double.then(double)
const incr_then_double = incr.then(double)

let ifThenElse = <a, b>(p: Fun<a, boolean>, _then: Fun<a, b>, _else: Fun<a, b>) => Fun((x: a) => (p.f(x) ? _then.f(x) : _else.f(x)))
// END

type Point = {
    x: number,
    y?: number // optional
}

var point : Point = {
    x: 10
}

// console.log(point.y)

type Countainer<a> = { content: a, counter: number }

let c_i: Countainer<number> = { content: 10, counter: 0 }
let c_s: Countainer<string> = { content: "Howdy!", counter: 0 }
let c_ss: Countainer<Array<string>> = { content: ["Howdy", "!"], counter: 0 }

let transform_countainer_content_num_to_bool = (f: Fun<number,boolean>, c: Countainer<number>): Countainer<boolean> => ({ content: f.f(c.content), counter: c.counter })

// console.log(transform_countainer_content_num_to_bool(is_odd.then(is_false), c_i).content) // Output: true

// let map_countainer = <a,b>(f: Fun<a,b>, c: Countainer<a>) : Countainer<b> => {
//     return { content: f.f(c.content), counter: c.counter }
// }

// let c: Countainer<number> = { content: 3, counter: 0 }
// let l: Countainer<boolean> = map_countainer(incr.then(decr.then(double)).then(incr).then(is_even), c)
// console.log(l);

let map_countainer = <a,b>(f: Fun<a,b>) : Fun<Countainer<a>, Countainer<b>> => Fun<Countainer<a>, Countainer<b>>(c => ({ content: f.f(c.content), counter: c.counter }))

let incr_countainer: Fun<Countainer<number>, Countainer<number>> = map_countainer(incr)
let is_countainer_even: Fun<Countainer<number>, Countainer<boolean>> = map_countainer(is_even)
let my_f: Fun<Countainer<number>, Countainer<boolean>> = incr_countainer.then(is_countainer_even)
let tick = Fun<Countainer<{}>, Countainer<{}>>(c => ({...c, counter: incr.f(c.counter) }))

// console.log(map_countainer(array_length).f(c_ss)) // Output: { content: 2, counter: 0 }
// console.log(my_f.f({ content: 10, counter: 0 }))
// console.log(incr_countainer.then(tick).then(is_countainer_even).then(tick).f({ content: 10, counter: 0 })) // Output: { content: false, counter: 2 }

// The Functor
// Properties are: identity and distribution of composition
type Option<a> = { kind: "none" } | { kind: "some", value: a }

let _print = (x: Option<{}>): string => {
    if (x.kind !== "some") {
        return "There is no value"
    }

    return `The value is: ${x.value}`
}

let none = <a>(): Option<a> => ({ kind: "none" })
let some = <a>(x:a): Option<a> => ({ kind: "some", value: x })

// console.log(_print(some<string>("Hello, World!")))

let something = some<string>("Something!")
// console.log(_print(something)) // Output: The value is: Something!

let map_Option = <a,b>(f: Fun<a,b>): Fun<Option<a>, Option<b>> => Fun(x => x.kind == "none" ? none<b>(): some<b>(f.f(x.value)))

let pipeline: Fun<Option<number>, Option<boolean>> = map_Option(id<number>().then(incr).then(double).then(is_greater_than_zero))
// console.log(pipeline.f(some<number>(1))) // Output: { kind: 'some', value: true }
// console.log(pipeline.f(none<number>())) // Output: { kind: 'none' }

// Functor Composition
type CountainerMaybe<a> = Countainer<Option<a>>
let map_Countainer_Maybe = <a,b>(f: Fun<a,b>): Fun<CountainerMaybe<a>, CountainerMaybe<b>> => map_countainer<Option<a>, Option<b>>(map_Option<a,b>(f))

var incr_test = map_Countainer_Maybe(incr)
var countainer: Countainer<number> = { content: 10, counter: 0 }
var test123: Countainer<Option<number>> = { content: { kind: "some", value: 1 }, counter: 0 }
var some_countainer = some<Countainer<number>>(countainer)

console.log(map_Countainer_Maybe(incr).f(test123)) // Output: { content: { kind: 'some', value: 2 }, counter: 0 }
